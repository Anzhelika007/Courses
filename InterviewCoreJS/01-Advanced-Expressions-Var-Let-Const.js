/* let и const ведут себя одинаково по отношению к лексическому окружению, области видимости.
Var - нет, вот отличия:*/


//- Для «var» не существует блочной области видимости. Область видимости переменных var ограничивается либо функцией, либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.
if (true) {
  var test = true; // используем var вместо let
}
console.log(test); // true, переменная существует вне блока if - Так как var игнорирует блоки, мы получили глобальную переменную test

// А если бы мы использовали let test вместо var test, тогда переменная была бы видна только внутри if
if (true) {
  let test1 = true; // используем let
}
console.log(test1); // Error: test is not defined

// Аналогично для циклов: var не может быть блочной или локальной внутри цикла:
for (var i = 0; i < 10; i++) {
  // ...
}
console.log(i); // 10, переменная i доступна вне цикла, т.к. является глобальной переменной

//Если блок кода находится внутри функции, то var становится локальной переменной в этой функции:
function sayHi() {
  if (true) {
    var phrase = "Привет";
  }
  console.log(phrase); // срабатывает и выводит "Привет"
}
sayHi();
console.log(phrase); // Ошибка: phrase не определена (видна в консоли разработчика)


//«var» допускает повторное объявление
let user;
let user; // SyntaxError: 'user' has already been declared
/*===========================*/
var user1 = "Пётр";
var user1; // ничего не делает, переменная объявлена раньше...нет ошибки
console.log(user); // Пётр
// Если дополнительно присвоить значение, то переменная примет новое значение:
var user2 = "Пётр";
var user2 = "Иван";
console.log(user2); // Иван


// «var» обрабатываются в начале запуска функции - Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
//!!! Объявления переменных «всплывают», но присваивания значений – нет.
function sayHi() {
  phrase = "Привет";
  console.log(phrase);
  var phrase;
}
sayHi();

// Технически полностью эквивалентен следующему (объявление переменной var phrase перемещено в начало функции):
function sayHi() {
  var phrase;
  phrase = "Привет";
  console.log(phrase);
}
sayHi();

// И даже коду ниже (как вы помните, блочная область видимости игнорируется):
function sayHi() {
  phrase = "Привет"; // (*)
  if (false) {
    var phrase;
  }
  console.log(phrase);
}
sayHi();

// Объявления переменных «всплывают», но присваивания значений – нет.
function sayHi() {
  console.log(phrase);
  var phrase = "Привет";
}
sayHi();
/*
Строка var phrase = "Привет" состоит из двух действий:

Объявление переменной var
Присвоение значения в переменную =.
Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:
*/
function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...
  console.log(phrase); // undefined
  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}
sayHi();


/*  IIFE - «Immediately-invoked function expressions» (сокращенно IIFE). */
// IIFE выглядит следующим образом:
(function() {
  var message = "Привет";
  alert(message); // Привет
})();
/* Здесь создаётся и немедленно вызывается Function Expression. Так что код выполняется сразу же и у него есть свои локальные переменные.*/

// Function Expression обёрнуто в скобки (function {...}), потому что, когда JavaScript встречает "function" в основном потоке кода, 
//он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, так что такой код вызовет ошибку:
function() { // <-- SyntaxError: Function statements require a function name

  var message = "Привет";

  alert(message); // Привет

}();
// Даже если мы скажем: «хорошо, давайте добавим имя», – это не сработает, потому что JavaScript не позволяет вызывать Function Declaration немедленно.
// ошибка синтаксиса из-за скобок ниже
function go() {

}(); // <-- нельзя вызывать Function Declaration немедленно

/* Так что скобки вокруг функции – это трюк, который позволяет объяснить JavaScript, что функция была создана в контексте другого выражения, а значит, 
что это Function Expression: ей не нужно имя и её можно вызвать немедленно.

Помимо круглых скобок существуют и другие способы сообщить JavaScript, что мы имеем в виду Function Expression: */

// Способы создания IIFE

(function() {
  alert("Круглые скобки вокруг функции");
})();

(function() {
  alert("Круглые скобки вокруг всего выражения");
}());

!function() {
  alert("Выражение начинается с логического оператора НЕ");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();
