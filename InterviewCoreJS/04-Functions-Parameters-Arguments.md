#### 04 Functions Parameters / Arguments

- Defining function parameters.

Определение параметров функции.
В нижеприведённом примере функции передаются два параметра: from и text.

```
function showMessage(from, text) { // параметры: from, text
  console.log(from + ': ' + text);
}
```

Функция всегда получает только копию значения:

```
function showMessage(from, text) {
  from = '_' + from + '_'; // немного украсим "from"
  console.log( from + ': ' + text );
}
let from = "Аня";
showMessage(from, "Привет"); // _Аня_: Привет
// значение "from" осталось прежним, функция изменила значение локальной переменной
console.log( from ); // Аня
```

Другими словами:
`Параметр` – это переменная, указанная в круглых скобках в объявлении функции.
`Аргумент` – это значение, которое передаётся функции при её вызове.

`Параметры по умолчанию`
Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =:

```
function showMessage(from, text = "текст не добавлен") {
  console.log( from + ": " + text );
}
showMessage("Аня"); // Аня: текст не добавлен
```

`Альтернативные параметры по умолчанию`
Иногда имеет смысл присваивать значения по умолчанию для параметров не в объявлении функции, а на более позднем этапе.

Во время выполнения функции мы можем проверить, передан ли параметр, сравнив его с undefined:

```
function showMessage(text) {
  // ...
  if (text === undefined) { // если параметр отсутствует
    text = 'пустое сообщение';
  }
  console.log(text);
}
showMessage(); // пустое сообщение
```

…Или мы можем использовать оператор ||:

```
function showMessage(text) {
  // если значение text ложно или равняется undefined, тогда присвоить text значение 'пусто'
  text = text || 'пусто';
  ...
}
```

Современные движки JavaScript поддерживают оператор нулевого слияния ??. Его использование будет лучшей практикой,
в случае, если большинство ложных значений, таких как 0, следует расценивать как «нормальные».

```
function showCount(count) {
  // если count равен undefined или null, показать "неизвестно"
  console.log(count ?? "неизвестно");
}
showCount(0); // 0
showCount(null); // неизвестно
showCount(); // неизвестно
```

- Differences in parameters passing by value and by reference.
  В JavaScript понимание разницы между передачей параметров по значению и по ссылке имеет решающее значение, поскольку оно влияет на то, как функции изменяют состояние приложения. Вот описание того, как оба метода работают в JavaScript:

`Передача по значению`
В JavaScript примитивные типы данных (такие как числа, строки, логические значения undefined, nullи Symbol) передаются по значению. Это означает, что когда вы передаете функции примитивный тип, JavaScript копирует значение переменной в новую переменную, доступную только внутри этой функции. Вот пример:

```
function modify(x) {
  x = 10;
}

let a = 5;
modify(a);
console.log(a); // Outputs: 5
```

В этом примере остается 5, поскольку внутри функции изменяется aтолько копия (x).a

`Передача по ссылке`
Непримитивные типы данных (например, объекты, массивы и функции) передаются по ссылке. Это означает, что когда вы передаете объект или массив функции, вы передаете ссылку на него, а не фактическую копию. Таким образом, изменения параметра внутри функции влияют на исходный объект или массив:

```
function modify(obj) {
  obj.key = "modified";
}

let myObj = { key: "original" };
modify(myObj);
console.log(myObj); // Outputs: { key: "modified" }
```

В этом примере myObjизменяется внутри функции, поскольку передается по ссылке. Функция изменяет реальный объект, а не его копию.

`Ключевые моменты`
Примитивы передаются по значению: изменения внутри функции не влияют на исходную переменную.
Объекты передаются по ссылке: изменения внутри функции могут изменить исходный объект.

- Handling a dynamic amount of function parameters.
  Обработка динамического количества параметров функции.

Все аргументы функции находятся в псевдомассиве `arguments` под своими порядковыми номерами.

```
function showName() {
  console.log( arguments.length );
  console.log( arguments[0] );
  console.log( arguments[1] );

  // Объект arguments можно перебирать
  // for (let arg of arguments) console.log(arg);
}

// Вывод: 2, Юлий, Цезарь
showName("Юлий", "Цезарь");

// Вывод: 1, Илья, undefined (второго аргумента нет)
showName("Илья");
```

`!!! Стрелочные функции не имеют "arguments"`  
Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.

`Оператор расширения`
Допустим, у нас есть массив чисел [3, 5, 1]. Как вызвать для него Math.max?
Просто так их не вставишь — Math.max ожидает получить список чисел, а не один массив.

```
let arr = [3, 5, 1];

console.log( Math.max(arr) ); // NaN
```

И тут нам поможет оператор расширения. Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное.
Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

```
let arr = [3, 5, 1];

console.log( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
```

Этим же способом мы можем передать несколько итерируемых объектов:

```
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log( Math.max(...arr1, ...arr2) ); // 8
```

Мы даже можем комбинировать оператор расширения с обычными значениями и оператор расширения можно использовать и для слияния массивов

```
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
let merged = [0, ...arr1, ...arr2];

console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

```
let str = "Привет";

console.log( [...str] ); // П,р,и,в,е,т
console.log( Array.from(str) ); // П,р,и,в,е,т
```
